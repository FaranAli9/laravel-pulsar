# Pulsar Architecture Guide

This project uses Pulsar's vertical slice architecture with two layers: a Service Layer for HTTP/application orchestration and a Domain Layer for pure business logic.

## Directory Structure

### Service Layer

```
app/Services/{Service}/
├── Providers/
│   ├── {Service}ServiceProvider.php
│   └── RouteServiceProvider.php
├── Routes/api.php
└── Modules/{Module}/
    ├── Controllers/    # HTTP handlers (thin)
    ├── Requests/       # Input validation
    ├── UseCases/       # Workflow orchestration
    └── Operations/     # Reusable action/query orchestration
```

### Domain Layer

```
app/Domain/{Domain}/
├── Models/         # Eloquent models
├── Actions/        # Atomic business operations
├── DTOs/           # Data transfer objects
├── Policies/       # Authorization
├── Events/         # Domain events
├── Enums/          # Business states
├── Exceptions/     # Business rule violations
└── Queries/        # Complex read operations
```

## Layer Responsibilities

| Layer | Responsibility | What NOT to do |
|-------|---------------|----------------|
| **Controller** | Extract validated data, call UseCase, return response | Never contain business logic |
| **Request** | Validate input structure, authorize | No business rule validation |
| **UseCase** | Orchestrate workflows, own transactions, emit events | Never coupled to HTTP Request objects |
| **Action** | Atomic business operation, validate business rules | Don't call other UseCases |
| **Operation** | Compose multiple Actions/Queries into reusable sequences | Don't contain business logic |
| **Query** | Complex read operations, reports | Never mutate state |
| **Model** | Data persistence, relationships | Keep thin, no business logic |

## Code Examples

### Controller (Thin HTTP Handler)

```php
class OrderController extends Controller
{
    public function __construct(
        private PlaceOrderUseCase $placeOrder
    ) {}

    public function store(PlaceOrderRequest $request): JsonResponse
    {
        $order = $this->placeOrder->execute(
            OrderData::from($request->validated())
        );

        return response()->json($order, 201);
    }
}
```

### Request (Validation Only)

```php
class PlaceOrderRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user()->can('create', Order::class);
    }

    public function rules(): array
    {
        return [
            'customer_id' => 'required|exists:customers,id',
            'items' => 'required|array|min:1',
            'items.*.product_id' => 'required|exists:products,id',
            'items.*.quantity' => 'required|integer|min:1',
        ];
    }
}
```

### UseCase (Workflow Orchestrator)

```php
class PlaceOrderUseCase
{
    public function __construct(
        private CreateOrderAction $createOrder,
        private UpdateStockAction $updateStock,
        private ReserveInventoryAction $reserveInventory,
    ) {}

    public function execute(OrderData $data): Order
    {
        return DB::transaction(function () use ($data) {
            // 1. Reserve inventory
            $this->reserveInventory->execute($data->items);

            // 2. Create order
            $order = $this->createOrder->execute($data);

            // 3. Decrement stock
            foreach ($data->items as $item) {
                $this->updateStock->execute(
                    $item['product_id'],
                    -$item['quantity']
                );
            }

            // 4. Emit event for side effects
            event(new OrderPlaced($order));

            return $order;
        });
    }
}
```

### Action (Atomic Business Operation)

```php
class UpdateStockAction
{
    public function execute(Product $product, int $quantity): Product
    {
        // Business rule validation
        if ($product->stock + $quantity < 0) {
            throw new InsufficientStockException($product);
        }

        // State mutation
        $product->update(['stock' => $product->stock + $quantity]);

        // Domain event
        if ($product->stock === 0) {
            event(new ProductOutOfStock($product));
        }

        return $product->fresh();
    }
}
```

### Operation (Reusable Action Orchestration)

```php
class SaveAddressOperation
{
    public function __construct(
        private FormatAddressAction $formatAddress,
        private RemoveNullFieldsAction $removeNullFields,
        private SaveAddressAction $saveAddress,
    ) {}

    public function execute(array $addressData, User $user): Address
    {
        // 1. Format address (standardize formatting)
        $formatted = $this->formatAddress->execute($addressData);

        // 2. Remove null fields (clean data)
        $cleaned = $this->removeNullFields->execute($formatted);

        // 3. Save address
        return $this->saveAddress->execute($cleaned, $user);
    }
}
```

Operations compose multiple Actions/Queries into reusable sequences that can be called by multiple UseCases. They prevent duplicating the same action chains across different workflows.

### DTO (Data Transfer Object)

```php
readonly class OrderData
{
    public function __construct(
        public int $customerId,
        public array $items,
        public string $shippingAddress,
        public ?string $notes = null,
    ) {}

    public static function from(array $data): self
    {
        return new self(
            customerId: $data['customer_id'],
            items: $data['items'],
            shippingAddress: $data['shipping_address'],
            notes: $data['notes'] ?? null,
        );
    }

    public function toArray(): array
    {
        return [
            'customer_id' => $this->customerId,
            'items' => $this->items,
            'shipping_address' => $this->shippingAddress,
            'notes' => $this->notes,
        ];
    }
}
```

### Query (Complex Read Operations)

```php
class GetLowStockProductsQuery
{
    public function execute(int $threshold = 10): Collection
    {
        return Product::query()
            ->where('stock', '<=', $threshold)
            ->where('status', ProductStatus::ACTIVE)
            ->with('category')
            ->orderBy('stock', 'asc')
            ->get();
    }
}
```

## Dependency Rules

```
Controllers → UseCases ✅
Controllers → Operations ✅ (for simple cases)
Controllers → Actions ❌ (use UseCase instead)

UseCases → Actions ✅
UseCases → Operations ✅
UseCases → Queries ✅
UseCases → Other UseCases ❌ (extract shared logic to Action)

Actions → Models ✅
Actions → Queries ✅
Actions → Other Actions ❌ (compose in UseCase instead)

Operations → Actions ✅
Operations → Models ✅
Operations → Other Operations ❌
Operations → UseCases ❌

Queries → Models ✅
Queries → Other Queries ❌
Queries → Actions ❌
```

### Layer Direction

```
Service Layer → Domain Layer ✅
Domain Layer → Service Layer ❌ (forbidden)
Service A → Service B ❌ (use events for cross-service communication)
```

## Dependency Injection (Octane-Safe)

**✅ ALWAYS: Constructor = Dependencies, execute() = Data**

```php
class PlaceOrderUseCase
{
    // Dependencies injected (Laravel resolves once in Octane)
    public function __construct(
        private CreateOrderAction $createOrder,
        private EmailService $emailService,
    ) {}

    // Data passed per request
    public function execute(OrderData $data): Order
    {
        // Implementation
    }
}
```

**❌ NEVER: Data in Constructor**

```php
// Breaks Laravel Octane - singletons can't hold state
public function __construct(private OrderData $data) {}
```

## Transaction Boundaries

**UseCases own transactions** (they see the full workflow):

```php
public function execute(OrderData $data): Order
{
    return DB::transaction(function () use ($data) {
        $order = $this->createOrder->execute($data);
        $this->updateInventory->execute($data->items);
        $this->recordPayment->execute($order);

        event(new OrderPlaced($order));

        return $order;
    });
}
```

**Actions don't manage transactions** (stay composable):

```php
class CreateOrderAction
{
    // No DB::transaction here
    public function execute(OrderData $data): Order
    {
        return Order::create([...]);
    }
}
```

## Event-Driven Side Effects

**✅ Decouple side effects with events:**

```php
class PlaceOrderUseCase
{
    public function execute(OrderData $data): Order
    {
        $order = DB::transaction(function () use ($data) {
            $order = $this->createOrder->execute($data);
            $this->updateInventory->execute($data->items);
            return $order;
        });

        // Side effects handled by listeners (async/queued)
        event(new OrderPlaced($order));

        return $order;
    }
}
```

**❌ Direct coupling:**

```php
// Don't do this in UseCase
$this->emailService->sendOrderConfirmation($order);
$this->smsService->sendNotification($order);
```

## Service Isolation

**✅ Event-based communication:**

```php
// Order service emits
event(new OrderPlaced($order));

// Inventory service listens
class DecrementStockOnOrder
{
    public function handle(OrderPlaced $event): void
    {
        // React independently
    }
}
```

**❌ Direct service coupling:**

```php
app(InventoryService::class)->decrementStock($items);
```

## Key Patterns

### UseCase vs Operation

| Aspect | UseCase | Operation |
|--------|---------|-----------|
| Purpose | Business workflow (full feature) | Reusable action/query sequence |
| Example | `PlaceOrderUseCase` | `SaveAddressOperation` |
| Calls | Actions, Operations, Queries | Actions, Queries (orchestrates them) |
| Reusability | Specific to one workflow | Shared across multiple UseCases |
| Transactions | Owns boundaries | Never manages |
| Called by | Controllers | UseCases, other Operations |

### Action Return Types

Actions can return:
- **Domain objects**: `CreateOrderAction` → `Order`
- **Collections**: `BulkUpdateProductsAction` → `Collection<Product>`
- **Booleans**: `ActivateAccountAction` → `bool`
- **Void**: Operations often return void
- **Primitives**: `CalculateTaxAction` → `float`

### When to Use What

1. **Business logic?** → Action
2. **Workflow orchestration?** → UseCase
3. **HTTP handling?** → Controller
4. **Input validation?** → Request
5. **Infrastructure (email, API)?** → Operation
6. **Complex read?** → Query
7. **Data transfer?** → DTO
8. **Business state?** → Enum
9. **Business rule violation?** → Exception
10. **State change notification?** → Event

## Testing Strategy

### Unit Tests (Actions)

```php
test('updates product stock', function () {
    $product = Product::factory()->create(['stock' => 10]);
    $action = new UpdateStockAction();

    $result = $action->execute($product, -3);

    expect($result->stock)->toBe(7);
});
```

### Integration Tests (UseCases)

```php
test('places order successfully', function () {
    Event::fake();
    $useCase = app(PlaceOrderUseCase::class);
    $data = OrderData::from([
        'customer_id' => 1,
        'items' => [['product_id' => 1, 'quantity' => 2]],
        'shipping_address' => '123 Main St',
    ]);

    $order = $useCase->execute($data);

    expect($order)->toBeInstanceOf(Order::class)
        ->and($order->status)->toBe(OrderStatus::PENDING);

    Event::assertDispatched(OrderPlaced::class);
});
```

### Feature Tests (Controllers)

```php
test('creates order via API', function () {
    $user = User::factory()->create();

    $response = $this->actingAs($user)
        ->postJson('/api/orders', [
            'customer_id' => 1,
            'items' => [['product_id' => 1, 'quantity' => 2]],
            'shipping_address' => '123 Main St',
        ]);

    $response->assertCreated()
        ->assertJsonStructure(['id', 'total', 'status']);
});
```

## Additional Resources

For complete documentation including installation, command reference, and detailed examples, see: https://github.com/faran/pulsar
