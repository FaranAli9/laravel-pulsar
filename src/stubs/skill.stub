---
name: pulsar
description: Enforces Pulsar vertical slice architecture rules when generating or modifying Laravel code. Activates when creating or changing controllers, requests, use cases, actions, operations, queries, models, DTOs, events, enums, exceptions, or policies.
license: MIT
metadata:
    author: faran
    framework: laravel
    architecture: pulsar
    pattern: vertical-slice
    strictness: mandatory
---

# Pulsar Architecture Skill

All Laravel code MUST follow Pulsar vertical slice architecture rules.
Violations are architectural errors.

---

## Mental Model

Two layers exist:

Service Layer: `app/Services/`
Domain Layer: `app/Domain/`

There is no `app/Http/Controllers`.
There is no `app/Models`.

Services are delivery boundaries scoped to a consumer audience (Admin, Client, Internal).
A Service is NOT a microservice, bounded context, or deployment unit.
Domain is pure business logic — Laravel-aware but delivery-agnostic.

---

## File Structure

Service Layer:

```
app/Services/{Service}/
  Providers/
  Routes/
  Modules/{Module}/
    Controllers/
    Requests/
    UseCases/
    Operations/
```

Domain Layer:

```
app/Domain/{Domain}/
  Models/
  Actions/
  DTOs/
  Policies/
  Events/
  Enums/
  Exceptions/
  Queries/
```

---

## Naming Conventions

Service Layer:

| Type       | Pattern                     | Example               |
| ---------- | --------------------------- | --------------------- |
| Service    | `{Audience}`                | `Admin`, `Client`     |
| Module     | `{Feature}` plural          | `Orders`, `Products`  |
| Controller | `{Resource}Controller`      | `OrderController`     |
| Request    | `{Verb}{Resource}Request`   | `CreateOrderRequest`  |
| UseCase    | `{Verb}{Resource}UseCase`   | `CreateOrderUseCase`  |
| Operation  | `{Verb}{Resource}Operation` | `PriceOrderOperation` |

Domain Layer:

| Type      | Pattern                   | Example                      |
| --------- | ------------------------- | ---------------------------- |
| Domain    | `{Capability}` singular   | `Order`, `Catalog`           |
| Model     | `{Entity}`                | `Order`                      |
| Action    | `{Verb}{Entity}Action`    | `CreateOrderAction`          |
| DTO       | `{Entity}Data`            | `OrderData`                  |
| Query     | `{Describe}{Result}Query` | `FindActiveOrdersQuery`      |
| Event     | `{Entity}{PastTenseVerb}` | `OrderCreated`               |
| Enum      | `{Entity}{Concept}`       | `OrderStatus`                |
| Exception | `{Descriptive}Exception`  | `InsufficientStockException` |
| Policy    | `{Entity}Policy`          | `OrderPolicy`                |

---

## Layer Responsibilities

**Controller** — Extract validated data, call UseCase, return HTTP response. No business logic. Call UseCases only (never Operations, Actions, or Queries directly).

**Request** — Validate input structure only. No business rules. Authorization via `authorize()` is allowed.

**UseCase** — Orchestrate workflow. Own `DB::transaction()`. Coordinate Actions, Operations, Queries. Emit Events. Never accept Request object. Never call another UseCase. Only UseCases invoke Operations.

**Operation** — Reusable workflow fragment shared across UseCases. Compose Actions and Queries and allow conditional branching when needed. No nested Operations. No transactions. No event emission. Never called directly by Controllers.

**Action** — Atomic business operation. Validate business invariants. No other Action calls. No Query calls. No transactions. No Service layer dependencies.

**Query** — Read-only. No mutations. No Action calls. No nested Queries. No Service dependencies.

**Model** — Relationships, fillable, casts, accessors, scopes. No business logic beyond that.

**DTO** — `readonly` class, constructor promotion, static `from(array $data)`. No logic.

**Event** — Readonly properties. No logic. Emitted by UseCases only.

**Enum** — Backed enum only (`string` or `int`).

**Exception** — Extends `Exception`. Descriptive name communicating the business rule violated.

**Policy** — Returns `bool`. Standard Laravel policy.

---

## Dependency Rules

Allowed:

```
Controller -> UseCase
UseCase    -> Action, Operation, Query, Event (emit)
Operation  -> Action, Query, Model
Action     -> Model
Query      -> Model
```

Forbidden:

```
Controller -> Operation, Action, or Query directly
UseCase    -> UseCase
Action     -> Action
Action     -> Query
Query      -> Query or Action
Operation  -> Operation or UseCase
Domain     -> Service (any direction)
Service A  -> Service B
```

---

## Transaction Ownership

Only UseCases call `DB::transaction()`.
Actions, Operations, and Queries never start transactions.

---

## Data Flow Rules

Constructor = dependencies only (injected services).
`execute()` = runtime data (DTOs, IDs, arrays).
Request objects never cross Controller boundary — convert to DTO or `$request->validated()` first.
Actions and Queries return domain types (models, collections, primitives, void). Never HTTP responses.

---

## Cross-Domain Coordination

When a workflow spans multiple domains (e.g., Order + Inventory + Payment), the UseCase coordinates. Actions stay within their own domain. Never have an Action call an Action from another domain.

---

## Event Side Effects

UseCases emit Events.
Listeners handle infrastructure (email, notifications, external APIs).
Never call mail, notification, or external services directly inside UseCase or Action.

---

## Routing

Routes live inside the Service, not in Laravel's default `routes/` directory.

```
app/Services/Admin/Routes/api.php
app/Services/Client/Routes/api.php
```

Each Service's `RouteServiceProvider` loads its own route file with appropriate prefix and middleware.

---

## End-to-End Example

This single example demonstrates the full flow: Controller → UseCase → Action, with correct namespaces, data flow, and transaction ownership.

```php
// app/Services/Admin/Modules/Orders/Controllers/OrderController.php
namespace App\Services\Admin\Modules\Orders\Controllers;

use App\Domain\Order\DTOs\OrderData;
use App\Services\Admin\Modules\Orders\Requests\CreateOrderRequest;
use App\Services\Admin\Modules\Orders\UseCases\CreateOrderUseCase;

class OrderController extends Controller
{
    public function store(CreateOrderRequest $request, CreateOrderUseCase $useCase)
    {
        $order = $useCase->execute(OrderData::from($request->validated()));
        return response()->json($order, 201);
    }
}
```

```php
// app/Services/Admin/Modules/Orders/UseCases/CreateOrderUseCase.php
namespace App\Services\Admin\Modules\Orders\UseCases;

use App\Domain\Order\Actions\CreateOrderAction;
use App\Domain\Inventory\Actions\ReserveStockAction;
use App\Domain\Order\DTOs\OrderData;
use App\Domain\Order\Events\OrderCreated;
use Illuminate\Support\Facades\DB;

class CreateOrderUseCase
{
    public function __construct(
        private CreateOrderAction $createOrder,
        private ReserveStockAction $reserveStock,
    ) {}

    public function execute(OrderData $data): Order
    {
        return DB::transaction(function () use ($data) {
            $order = $this->createOrder->execute($data);
            $this->reserveStock->execute($order->items);
            event(new OrderCreated($order));
            return $order;
        });
    }
}
```

```php
// app/Domain/Order/Actions/CreateOrderAction.php
namespace App\Domain\Order\Actions;

use App\Domain\Order\DTOs\OrderData;
use App\Domain\Order\Models\Order;

class CreateOrderAction
{
    public function execute(OrderData $data): Order
    {
        return Order::create([
            'customer_id' => $data->customerId,
            'status'      => OrderStatus::Pending,
        ]);
    }
}
```

This example also demonstrates cross-domain coordination: the UseCase imports from both `Order` and `Inventory` domains. The Actions themselves have no knowledge of each other.

---

## Forbidden Patterns

- Fat Controllers containing business logic
- Controllers calling Operations directly
- Actions calling other Actions
- Actions calling Queries (pass the data in instead)
- Operations emitting domain events
- Transactions inside Actions or Operations
- UseCases calling other UseCases
- Request objects leaking past Controller
- Business logic in Models beyond accessors/scopes

If you feel tempted to do any of the above, the architecture is being violated.

---

## Scaffolding

Use Pulsar CLI to generate files to ensure correct namespace and location.

```bash
# Service Layer
pulsar make:service Admin
pulsar make:controller OrderController Orders Admin --resource
pulsar make:request CreateOrderRequest Orders Admin
pulsar make:use-case CreateOrderUseCase Orders Admin
pulsar make:operation PriceOrderOperation Orders Admin

# Domain Layer
pulsar make:model Order Order
pulsar make:action CreateOrderAction Order
pulsar make:dto OrderData Order
pulsar make:event OrderCreated Order
pulsar make:query FindActiveOrdersQuery Order
```

---

## Uncertainty Protocol

If unsure about placement, layer type, or domain ownership:
STOP and ask the user.
Never guess.
